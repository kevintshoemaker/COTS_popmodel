{
    "contents" : "---\ntitle: \"CoTS_Interpolation\"\nauthor: \"Samuel Matthews\"\ndate: \"20 July 2016\"\noutput: html_document\n---\n\nThe purpose of this script is to interpolate CoTS presence/abundance based on LTMP data for each year of collected data. Here I use the inverse distance weighted (IDW) interpolation method from the *gstat* package. The interpolation uses a fixed radius of 0.1 degree. Any cell in the grid which contained less than three points was assigned a ‘no data’ value.\n\nThe interpolation will only be applied to pixels that contain reef, and abundace values will be multiplied by the percentage of reef conatined within each cell.\n\nThings I need\n\n* Reef pixel layer\n* manta tow data for each year\n* round x and y coordinates to nearest 0.01 degree and sum CoTS counts\n* populate xyYear table with CoTS abundances\n* create raster layer for each year\n* perform IDW to interpolate\n\n### FOR TOMORROW\n\n1. Redo Assignment to neighbour --> decide what to do with most northern sites amd duplicates\n2. Interpolate using IDW and convert to netCDF file\n\n```{r}\n# 1. Import Manta data\n# 2. Average CoTS count per manta tow for each year\n# 3. Find the nearest GBRMPA site to LMTP\n# 4. Add CoTS data to XYZ\nlibrary(plyr)\nlibrary(dplyr)\nlibrary(reshape2)\nlibrary(tidyr)\nlibrary(sp)\nlibrary(rgeos)\nlibrary(gstat)\n# 1.\nsetwd(DATA_DIRECTORY)\nmanta <- read.csv(\"ltmp/manta.csv\") #LTMP Manta Tow Data\nXYZ <- read.csv(\"XYZGrid.csv\") #GBRMPA 0.01 degree grid\nbenthos <- read.csv(\"ltmp/benthos.csv\")\n\n# 2.\ncolnames(manta)[6] <- \"LONG\"\n\nmanta_year <- ddply(manta, c(\"REEF_NAME\", \"LONG\", \"LAT\", \"REPORT_YEAR\"), \n                    summarise, mean_COTS = mean(COT_COUNT)) %>% \n                    dcast(REEF_NAME + LAT + LONG ~ REPORT_YEAR, value.var=\"mean_COTS\")\n\n# 3.\n#### I have mean CoTS count for each year, now I need to attibute each LTMP site to the closest on the GBRMPA grid ####\nsp.mydata <- manta_year\ncoordinates(sp.mydata) <- ~LONG+LAT # define the coords to creat Spatial Points data frame\nsp.mydata1 <- XYZ\ncoordinates(sp.mydata1) <- ~LONG+LAT # same as above\nGdist <- gDistance(sp.mydata,sp.mydata1, byid = T) #calculate the geographic distance between every point\n\n\n#### so i have a matrix with LTMP sites as columns and GBRMPA sites as rows, I need to find which row has the min distance ####\nmin.d <- apply(Gdist, 2, which.min) #creates vector of the minimum distances which we use to index the cords of XYZ\nmin.gd <- apply(Gdist, 2, min)\n\nmanta_year$min.gd = min.gd # add the minimum geographic distance to the dataframe to remove those that have been displaced greater than 0.01 degrees\n\n\n#Double check that the matches are ok\ncoord.matches <- cbind(manta_year[1:3],XYZ[min.d,1:2], min.gd)\n\n# write out tables to inspect in ARCGIS\nwrite.table(manta_year[1:3], file=\"LTMP_Sites.txt\", row.names = F)\nwrite.table(XYZ[c(1:2,6)], file=\"GBRMPA_Sites.txt\", row.names = F)\n\n#the problem we have is that the most northern sites were not included in our grid leading to overlapping nearest neighbours and large distances\n\nmanta_year[,2:3] <- XYZ[min.d,1:2]\ncolnames(manta_year)[2:3] <- c(\"LONG\", \"LAT\") # coords were in different order\n\n# 4.  \nXYZ_COTS <- left_join(XYZ, manta_year, by=c(\"LAT\", \"LONG\")) %>% \n             filter(min.gd < 0.02 | is.na(min.gd)) #join if the distance that the LTMP site has been moved is below a certain threshold and keeps NA's\n```\n\n* For some reason I have 13 duplicate rows, what do i do with them? It won't be as bad when we have the grid reoorganised a bit because most are actually near to reefs but these reef fell off the 0.01 grid that was imposed upon them, therefore there needs to be a buffer so that these small reefs don't get left out.. We need a grid cell and any cell that contains reef need to be included\n\n```{r}\nduplicates <- which(duplicated(min.d))\nduplicates1 <- which(duplicated(XYZ_COTS[,1:2]))\n#lets have a look at the dataframe of duplicated rows\nduplicate.df <- XYZ_COTS[duplicates1,]\n```\n\n* For now however I will carry on with the interpolation of the dataset I have now using gstat\n\n```{r}\ncoordinates(XYZ_COTS) = ~LONG+LAT\nsummary(XYZ_COTS)\nbubble(XYZ_COTS, \"1992\")\ndata(meuse)\ncoordinates(meuse) = ~x+y\nbubble(meuse, \"zinc\", col=c(\"#00ff0088\", \"#00ff0088\"), main = \"zinc concentrations (ppm)\")\n\ndata(meuse.grid)\ncoordinates(meuse.grid) = ~x+y\ngridded(meuse.grid) = TRUE\nimage(meuse.grid[\"dist\"])\ntitle(\"distance to river (red = 0)\")\n\nzinc.idw = idw(zinc~1, meuse, meuse.grid)\n\n#go back and try o interpolate without rounding to the grid cell level\ncoordinates(manta_year) = ~LONG+LAT\ncoordinates(XYZ) = ~LONG+LAT\ngridded(XYZ) = TRUE\n#image(XYZ[\"Shape_area\"])\n\n#for interpolation, each year has to have complet cases so I will have to write a function that cuts up the data frame, removes incomplete cases and then passes it to idw function and eventually spits out an interpolated raster\n\nCoTS.1991 = na.omit(data.frame(coordinates(manta_year), manta_year@data$`1991`))\ncolnames(CoTS.1991)[3] = \"mean.COTS\"\ncoordinates(CoTS.1991) = ~LONG+LAT \nCOTS.idw = idw(mean.COTS~1, CoTS.1991, XYZ)\nclass(COTS.idw)\nspplot(COTS.idw[\"var1.pred\"], main = \"Mean COTS abundance Interpolation 1991\")\n```\n\n* Now we see how the interpolation works we right a function that takes the follwing inputs\n\n  + *Data*: Data frame (in this case the manta_year data) must have LONG and LAT as 2nd and 3rd  columns\n  + *Years*: vector of the years from the LTMP that we wish to interpolate\n  + *Grid*: Spatial Pixels data frame\n  + *Convert2ASCII*: Logical to decide whether to convert the pixel data frame to ASCII for export\n  + *CreateZip*: Logical to decide whether to create a zip file\n  \n```{r}\n\ncoordinates(XYZ) = ~LONG+LAT\ngridded(XYZ) = TRUE\n\n# So ill write a function that simply interpolates \nidw.interpolation <- function(Year, maxdist, nmin) {\n  #first we need to subset the manta_year data set\n    Obs = na.omit(data.frame(manta_year[,2:3],manta_year[,Year-1983 +4])) #create observations of CoTS for year i\n    colnames(Obs)[3] = \"mean.COTS\"\n    coordinates(Obs) = ~LONG+LAT \n    COTS.idw = idw(mean.COTS~1, Obs, XYZ, maxdist = maxdist, nmin= nmin)\n    #results = spplot(COTS.idw[\"var1.pred\"], main = \"CoTS interpolation\")\n    return(COTS.idw)\n}\n\nidw.interpolation.df <- function(Year, maxdist, nmin) { ## returns the object as a list of dataframes\n  #first we need to subset the manta_year data set\n    Obs = na.omit(data.frame(manta_year[,2:3],manta_year[,Year-1983 +4])) #create observations of CoTS for year i\n    colnames(Obs)[3] = \"mean.COTS\"\n    coordinates(Obs) = ~LONG+LAT \n    COTS.idw = as.data.frame(idw(mean.COTS~1, Obs, XYZ, maxdist = maxdist, nmin= nmin))\n    #results = spplot(COTS.idw[\"var1.pred\"], main = \"CoTS interpolation\")\n    return(COTS.idw)\n}\n\nYears <- 1983:2015\n\nCOTS.interpolation <- lapply(Years, FUN = idw.interpolation, maxdist=1, nmin=3) #apply intepolation function for each year\nnames(COTS.interpolation) <- Years #name the list so they can be retrieved by year\n\n\nCOTS.interpolation.df <- lapply(Years, FUN = idw.interpolation.df, maxdist=1, nmin=3) #apply intepolation function for each year\nnames(COTS.interpolation.df) <- Years #name the list so they can be retrieved by year\n\nNA2NODATA <- function(x){ #Converts NA's to NoData for use in ARcMap\n  x[is.na(x)] <- \"NoData\"\n  return(x)\n}\n\nCOTS.interpolation.df.arc <- lapply(COTS.interpolation.df, FUN = NA2NODATA)\n\nsetwd(DATA_DIRECTORY)\nlapply(1:length(COTS.interpolation.df), function(i) write.table(COTS.interpolation.df[[i]][,-4], \n                                      file = paste0(\"ltmp/COTS_Interpolation/COTS_\",names(COTS.interpolation.df[i]), \".txt\"),\n                                      row.names = FALSE))\n\n###Now I can add the interploated data to the XYZ data frame\n```\n\n```{r}\n#Combine into 1 data frame\n\nfor(i in 1:length(COTS.interpolation.df)) names(COTS.interpolation.df[[i]])[3] <- paste0(\"X\",1982+i) \nfor(i in 1:length(COTS.interpolation.df)) COTS.interpolation.df[[i]][4] <- NULL\nXYZ_COTS.int <- Reduce(function(x,y)merge(x,y, by=c(\"LAT\", \"LONG\")), COTS.interpolation.df)  \n\n#merge with XYZ \nXYZ_COTS.int <- left_join(XYZ, XYZ_COTS.int, by=c(\"LAT\", \"LONG\"))\nwrite.table(XYZ_COTS.int, file = \"Interpolation/COTS_Intepolated.txt\", row.names = F)\n```\n\n### Convert IDW to JPEG's\n\n```{r}\n#for(i in 2:33){\n#  mypath <- file.path(paste(\"Interpolation/COTS_\", Years[i], \".jpeg\", sep = \"\"))\n#  jpeg(file=mypath)\n#  mytitle = paste(\"CoTS Interpolation \", Years[i], sep=\"\")\n#  spplot(COTS.interpolation[[i]][\"var1.pred\"], main = mytitle)\n#  #savePlot(filename = mypath, type = 'jpg')\n#  dev.off()\n}\n\nmypath <- file.path(paste(\"Interpolation/COTS_\", Years[33], \".jpeg\", sep = \"\"))\n  #dev.off()\n  #windows()\n  jpeg(file=mypath)\n  #mytitle = paste(\"my title is\", names[i])\n  spplot(COTS.interpolation[[33]][\"var1.pred\"], main = paste(\"CoTS Interpolation \", Years[33], sep=\"\"))\n  #savePlot(filename = mypath, type = 'jpg', device = dev.cur())\n  dev.off()\n```\n\n### COnvert into ASCII for ARCGIS\n\n```{r}\n# Function to convert .txt to ASCII then apply to function to a groupof files\ntxt2ASCII <- function(filename, plot=F) {\n  #Red in .txt file\n   setwd(DATA_DIRECTORY)\n   df <- read.table(paste0(\"ltmp/COTS_Interpolation/\", filename, \".txt\"), header =T)\n   coordinates(df) <- ~LONG+LAT\n   #co-erce to SpatialPixelsDataFrame\n   gridded(df) <- TRUE\n   #co-erce to raster\n   rasterDF <- raster(df)\n   crs(rasterDF) <- projection\n   if(plot) plot(rasterDF, main=paste0(filename, \" Interpolation\"))\n   setwd(SPATIALDATA_DIRECTORY)\n   writeRaster(rasterDF,filename=paste0(\"COTS_Interpolation/\", filename, \".asc\"),format=\"ascii\",overwrite=T)\n}\nsetwd(DATA_DIRECTORY)\nlibrary(tools)\nfiles <- list.files(\"ltmp/COTS_Interpolation\")\nfiles <- lapply(files, FUN = file_path_sans_ext)\nlapply(files, FUN = txt2ASCII)\n",
    "created" : 1475023329224.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1017227879",
    "id" : "8CFF9356",
    "lastKnownWriteTime" : 1473131853,
    "path" : "C:/Users/jc312264/Google Drive/RStudio_Projects/CoTSInterpolation.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "type" : "r_markdown"
}