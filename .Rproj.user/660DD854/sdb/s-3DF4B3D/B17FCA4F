{
    "contents" : "########################\n# Functions for modeling COTS demography and dispersal\n########################\n#   Authors: Kevin Shoemaker, Sam Matthews\n#\n#   28 September 2016 - Updated initializeCoTSabund to matrix form\n#                     - started scripting mortality, fecundity, dispersal functions\n#\n#   THINGS TO DO:\n#         1. Set initial adult densities (use 1996 to line up with coral model) - check dates on report year\n#         2. Write out params of m,f and d functions\n#         3. Do we want to have CoTS pops at the reef level\n\n\n###################\n#  BASIC VITAL RATE AND GROWTH FUNCTIONS \n###################\n\n   # converts diameter (in mm) to mass (in grams)\n\nCOTS_MassFromDiam <- function(Diam){\n  Mass <- 6.29*10^-5*Diam^2.929\n  return(Mass)\n}\n\n   # converts female mass to total larval fecundity \nCOTS_FecFromMass <- function(Mass){\n  Fec <- 558*Mass^1.439\n  return(Fec)\n}\n\nCOTS_StableStage <- c(0.9803, 0.0171, 0.0026)   # very approximate stable stage distribution (J1, J2, Adult: see below for back-of-the-envelope calculation)\n\n###################\n# initializeCOTSabund\n##########\n# OBJECTIVE:\n#    generate an object for storing the COTS abundance in each pixel. \n# PARAMS:\n#    - reefmap: raster template for the study region: NA outside of reefs, reef ID value within reefs \n#    - PopData: data frame containiing PIXEL ID's, percent reef cover and environ vriable\n#    - COTSInterp: txt file containing interpolated values of COTS Manta tow, giving a value for CoTS density\n#    - Year: Which year we are using as our starting values\n#    - Detectability: detectability of adult CoTS from MAnata tow surveys\n#    - stagenames: vector of stagenames eg J1, J2, A1\n#    - nstages: number of stages\n#    - nreefs: number of reefs in simulation\n#    - npops: number of separate populations - initially using every reef pixel as a reef\n# RETURNS:\n#    - COTSabund: spatially-structured and stage-structured COTS abundance\n#           COTSabund$J_1: vector representing spatially structured abundance of Juvenile stage 1 individuals\n#           COTSabund$J_2: vector representing spatially structured abundance of Juvenile stage 2 individuals\n#           COTSabund$A: vector representing spatially structured abundance of reproductive adult individuals\n#           COTSabund$S: vector representing spatially structured abundance of senile adult individuals\n#           NOTE: larvae are not considered explicitly here. \n###################\n\nsetwd(DATA_DIRECTORY)\nPopData <- read.table(\"PopData.txt\", header = TRUE, sep = \"\\t\")\nCOTSInterp <- read.table(\"COTS_Interpolated.txt\", header = TRUE, sep = \"\\t\")\n\nstagenames <- c('J_1', 'J_2', 'A')\n\ninitializeCOTSabund <- function(PopData, COTSInterp, Year, stagenames, COTS_StableStage){\n  \n  ### set NA Values in interpolation to 0\n  COTSInterp[is.na(COTSInterp)] <- 0\n  \n  npops <- length(PopData[,1])\n  nstages <- length(stagenames)\n  \n  ### Set up the COTS abundance object\n  COTSabund <- matrix(0,nrow=npops, ncol=nstages)\n  colnames(COTSabund) <- stagenames\n  \n  ### Set up reference for year\n  colname <- paste('X', Year, sep=\"\")\n  \n  ### Update abundances based from interpolated manta tow data\n  COTSabund[,'A'] <- COTSInterp[,colname] * 1500 * (PopData$reefpercent/100)   #need to multiply by function from observations to density\n  COTSabund[,'J_2'] <- COTSabund[,'A'] * (COTS_StableStage[2]/COTS_StableStage[3])\n  COTSabund[,'J_1'] <- COTSabund[,'A'] * (COTS_StableStage[1]/COTS_StableStage[3])\n  return(COTSabund)\n}\n\ninitCOTS <- initializeCOTSabund(PopData = PopData, COTSInterp = COTSInterp, Year=1996, stagenames, COTS_StableStage = COTS_StableStage)\n\n    \n###################\n# CoTS_StageTransition\n##########\n# OBJECTIVE: Transition all individuals through life stages\n#    \n# PARAMS: \n#     - COTSabund: Matrix of CoTS abundances for which to transition\n#     - COTSmort: named Vector of natural mortality rates for each stage\n#     - COTSremain: named Vector of proportions of individuals that remain in current life stage\n#    \n# RETURNS: \n#     - newCOTSabund: COTS abund updated after 6 month time step\n#     \n###################\n\nCOTSmort <- c(0.7,0.4,0.1)\nnames(COTSmort) <- stagenames\n\nCOTSremain <- c(0.02,0.2,1) # proportion remianing in each life stage --> we can make this a function of resource\nnames(COTSremain) <- stagenames\n\nCOTS_StageTransition <- function(COTSabund, COTSmort, COTSremain) {\n  \n  #Set up matrices\n  newCOTSabund <- matrix(0,nrow=nrow(COTSabund), ncol=ncol(COTSabund))\n  colnames(newCOTSabund) <- colnames(COTSabund)\n  COTS_Mort <- matrix(0,nrow=nrow(COTSabund), ncol=ncol(COTSabund))\n  colnames(COTS_Mort) <- colnames(COTSabund)\n  COTS_Remain <- matrix(0,nrow=nrow(COTSabund), ncol=ncol(COTSabund))\n  colnames(COTS_Remain) <- colnames(COTSabund)\n  COTS_Trans <- matrix(0,nrow=nrow(COTSabund), ncol=ncol(COTSabund))\n  colnames(COTS_Trans) <- colnames(COTSabund)\n  \n  # apply mortality\n  COTS_Mort <- sweep(COTSabund,MARGIN=2,COTSmort,`*`)\n  # update abundance\n  newCOTSabund <- COTSabund - COTS_Mort\n  \n  # number of COTS remaining and transitioning for each stage based on post-mortality abundaces\n  COTS_Remain <- sweep(newCOTSabund,MARGIN=2,COTSremain,`*`)\n  COTS_Trans <- sweep(newCOTSabund,MARGIN=2,1-COTSremain,`*`)\n  \n  # update newCOTSabund\n  newCOTSabund[, 'J_1'] <- COTS_Remain[,'J_1']\n  newCOTSabund[, 'J_2'] <- COTS_Remain[,'J_2'] + COTS_Trans[,'J_1']\n  newCOTSabund[, 'A'] <- COTS_Remain[,'A'] + COTS_Trans[,'J_2']\n  return(newCOTSabund)\n}\n\nt1 <- COTS_StageTransition(COTSabund = initCOTS, COTSmort = COTSmort, COTSremain = COTSremain)\n\nhead(initCOTS)\nhead(t1)\n\n###################\n# CoTS_Fecundity\n##########\n# OBJECTIVE: 1. Assume a size distribution amongst adults and then sample diameters\n#            2. Convert diameter to mass \n#            3. Convert mass to eggs\n#            4. Multiply total eggs by connectivity matrix\n#    \n# PARAMS: \n#     - COTSabund: standard abundance matrix for the time step\n#     - mean: mean of the size distribution of COTS adults\n#     - sd: standard deviation of size distribution\n#     - npops: number of pixels\n#    \n# RETURNS:\n#     - TotalLarvae: Total larvae produced per pixel\n#     \n###################\n\nCOTS_Fecundity <- function(COTSabund, mean, sd, npops) {\n    \n  ### Intitialize matrix to store total eggs\n  COTS_Eggs <- vector(mode = \"numeric\", length = npops)\n    for (r in 1:npops) {\n        Sizes <- rnorm(COTSabund[r,'A'], mean, sd)\n        COTS_Eggs[r] <- sum(COTS_FecFromMass(COTS_MassFromDiam(Sizes)))\n    }\n    return(COTS_Eggs)\n}\n\n\nEGGS <- COTS_Fecundity(t1, 35, 10, npops)\n\n###################\n# CoTS_Fertilisation ----\n###################\n# OBJECTIVE: Determine the fertilisation success(%) at different densities of COTS (between 0-150,000)\n#    \n# PARAMS:\n#     - nLarvae: vector of number of larvae produced for each pixel\n#     - Conn: 13577x13577 Connectivity matrix containing proportion of original larvae reching every other cell\n#    \n# RETURNS:\n#     - \n#     \n###################\n\n\n###################\n#Define Fertilisation by distance fucntion\n#####\n\nFert.data <- data.frame(Dist = c(0,2,4,8,16,32,64,100), PercFert = c(90,86.5, 71.8,71.9,41.5,26.8,20.5,5.8))\n\nm1 <- as.formula(PercFert ~ p * exp(k * Dist)) #standard \nm2 <- as.formula(PercFert ~ p * exp(k * Dist) + q) #standard \nm3 <- as.formula(PercFert ~ p * exp(k * Dist) + (92-p)) #fixed intercept of 92%\n\nem <-function(x,p,k,q) {(p*exp(k*x)) + q}\nem.fixed <-function(x,p,k,f) {(p*exp(k*x)) + (f-p)}\nem2<-function(x,p,k) {(p*exp(k*x))}\n\n\nnls1 <- nls(m1,start=list(p=80,k=-0.05), data = Fert.data)\nnls2 <- nls(m2,start=list(p=90,k=-0.05, q=10), data = Fert.data, control = list(maxiter=500))\nnls3 <- nls(m3,start=list(p=80,k=-0.05), data = Fert.data)\n\n###################\n#Retrieve best fit model parameters\n#############\nBestFitPars <- function(nls.object){\n  confints <- confint(nls.object)\n  bestpars <- nls.object$m$getPars()\n  upperpars <- confints[,2] \n  lowerpars <- confints[,1]\n  pars <- data.frame(bestpars,upperpars,lowerpars)\n  return(pars)\n}\n\nBestFitPars(nls1)\nBestFitPars(nls2)\nBestFitPars(nls3)\n\n###################\n# Plot Fertilisation Function \n############\n\nData <- Fert.data\nnls.object <- nls1\n\nnlsCIplot <- function(nls.object, Data) {\n  \n  (confints <- confint(nls.object))\n  (bestpars <- nls.object$m$getPars())\n  upperpars <- confints[,2] \n  lowerpars <- confints[,1]\n  (pars <- data.frame(bestpars,upperpars,lowerpars))\n  \n  fit.data <- data.frame(x=seq(0,200,len=100), \n                         best=NA, upper=NA, lower=NA)\n  fit.data$best <- em(fit.data$x, bestpars[1], bestpars[2], bestpars[3])\n  \n  fit.data$upper <- em(fit.data$x, upperpars[1], upperpars[2], upperpars[3])\n  fit.data$lower <- em(fit.data$x, lowerpars[1], lowerpars[2], lowerpars[3])\n  ggplot(fit.data, aes(y=best, x=x)) +\n    geom_line() + theme_classic() +\n    geom_ribbon(aes(ymin=lower, ymax=upper), fill='blue', alpha=0.2) +\n    geom_point(data=Data, aes(x=Dist,y=PercFert)) +\n    xlab(\"Distance\") +\n    ylab(\"Percentage Eggs Fertilised\") +\n    ggtitle(\"Fertilisation Function\")\n}\n\nnlsCIplot2 <- function(nls.object, Data) {\n  \n  (confints <- confint(nls.object))\n  (bestpars <- nls.object$m$getPars())\n  upperpars <- confints[,2] \n  lowerpars <- confints[,1]\n  (pars <- data.frame(bestpars,upperpars,lowerpars))\n  \n  fit.data <- data.frame(x=seq(0,200,len=100), \n                         best=NA, upper=NA, lower=NA)\n  fit.data$best <- em2(fit.data$x, bestpars[1], bestpars[2])\n  \n  fit.data$upper <- em2(fit.data$x, upperpars[1], upperpars[2])\n  fit.data$lower <- em2(fit.data$x, lowerpars[1], lowerpars[2])\n  ggplot(fit.data, aes(y=best, x=x)) +\n    geom_line() + theme_classic() +\n    geom_ribbon(aes(ymin=lower, ymax=upper), fill='blue', alpha=0.2) +\n    geom_point(data=Data, aes(x=Dist,y=PercFert)) +\n    xlab(\"Distance\") +\n    ylab(\"Percentage Eggs Fertilised\") +\n    ggtitle(\"Fertilisation Function\")\n}\n\nnlsCIplot(nls2, Fert.data)\nnlsCIplot2(nls1, Fert.data)\n\n(bestpars <- BestFitPars(nls1))\n\n###################\n# Fertilisation by Density ------\n###############################\n# This section will determine the Von Bertalanffy Growth Parameters for 10 different sex ratios and plot the results\n\ngeomSeries <- function(base, max) {\n  base^(0:floor(log(max, base)))\n}\n\n\nDensities <- geomSeries(2, 10000)\nDensities <- c(Densities, 1536, 2560, 3072, 3584, 5120, 6144,7168,9216)\nDensities <- sort(Densities)\nSexRatio <- c('M' = 0.2, 'F' = 0.8)\nSexRatios <- list(c('M' = 0.1, 'F' = 0.9), c('M' = 0.2, 'F' = 0.8), c('M' = 0.3, 'F' = 0.7),\n                  c('M' = 0.4, 'F' = 0.6), c('M' = 0.5, 'F' = 0.5), c('M' = 0.6, 'F' = 0.4),\n                  c('M' = 0.7, 'F' = 0.3), c('M' = 0.8, 'F' = 0.2), c('M' = 0.9, 'F' = 0.1))\n\nexpParams <- bestpars[,1]\n\nsexes <- seq(0.1,0.9, 0.1)\nsexes <- paste(\"M\", sexes, sep=\"\")  \n# I will have to convert fertilisation based on reefpercent\n\nFertVsDensity <- function (SexRatio, Densities, expParams) {\n  # Place all adults amongst landscape\n  props <- data.frame(Dens=Densities, Female = NA, Male = NA)\n  fertbydens <- list()\n  \n  for (i in 1:length(Densities)){\n    coordsx <- runif(Densities[i], min = 0, max = 1000)\n    coordsy <- runif(Densities[i], min = 0, max = 1000)\n    coords <- data.frame(x = coordsx, y = coordsy)\n    # randomly assign each coordinate pair as male or female\n    coords$sex <- sample(c('M', 'F'), length(coordsx), replace = T, prob = SexRatio)\n    #determine number of males and females\n    props[i,2:3] <- prop.table(table(coords$sex))[1:2]*Densities[i]\n  \n    if(sum(is.na(props[i,2:3]))==1) {\n      fertbydens[[i]] <- rep(NA, Densities[i])\n      next\n    } else {\n    \n      # now for each female, we calculate the distance and the probability that her eggs were NOT\n      # fertilised by that male\n    \n      Females <- as.matrix(coords[coords[,'sex']=='F',][,1:2])\n      Males <- as.matrix(coords[coords[,'sex']=='M',][,1:2])\n      # Each row has the distance between each female and male\n      DistMat <- SpatialTools::dist2(Females, Males)\n      # convert distance into probability of not fertalising\n      em2 <- function(x,p,k) {(1- (p*exp(k*x))/100)}\n      DistMat.NotFert <- matrix(sapply(DistMat, FUN = em2, expParams[1], expParams[2]), \n                       nrow = length(Females[,1]), ncol = length(Males[,1]))\n      #Multiply across each row to find out the probability that egss from that female were not fertilised\n      # by any male\n      NotFert <- apply(DistMat.NotFert, MARGIN = 1, FUN = prod)\n      fertbydens[[i]] <- 1-NotFert\n    }\n  }\n  # name the list by the desnity of the population\n  names(fertbydens) <- Densities\n  #convert into a dataframe for plotting\n  dens <- rep(Densities, each = 1, times = props[,'Female'])\n  fert <- unlist(fertbydens)\n  fert.df <- data.frame(dens,fert)\n  return(list(Props = props, FertbyDens.df = fert.df, FertbyDens = fertbydens))\n}\n\nf1 <- FertVsDensity(Densities, SexRatio, expParams) \n\nl1 <- lapply(SexRatios, FUN = FertVsDensity, expParams=expParams, Densities=Densities)\n\nnames(l1) <- sexes \nggplot(data=f1[[2]], aes(x=dens, y=fert)) +\n  geom_point() +\n  geom_smooth() +\n  theme_classic()\nhead(l1[[1]][[2]])\nggplot(data=l1[[1]][[2]], aes(x=dens, y=fert)) +\n  geom_point() +\n  geom_smooth() +\n  theme_classic()\nggplot(data=l1[[5]][[2]], aes(x=dens, y=fert)) +\n  geom_point() +\n  geom_smooth() +\n  theme_classic()\nggplot(data=l1[[7]][[2]], aes(x=dens, y=fert)) +\n  geom_point() +\n  geom_smooth() +\n  theme_classic()\nggplot(data=l1[[9]][[2]], aes(x=dens, y=fert)) +\n  geom_point() +\n  geom_smooth() +\n  theme_classic()\n\n###################\n# Von Bertalanffy Growth\n#################\n#\n# This function takes the data created by the FertVsDensity function to define the parameters of the \n# Von Bertalanffy Growth for each of our potential densities\n#\n#\nFvD <- l1\n\nSSQ <- function(theta, x) {\n  Linf <- theta[1]\n  K <- theta[2]\n  t0 <- theta[3]\n  epsilon <- rep(0, length(dens))\n  lpred <- rep(0, length(dens))\n  for (i in 1:length(dens)) {\n    lpred[i] <- Linf * (1 - exp(-K * (dens[i] - t0)))\n    epsilon[i] <- (fert[i] - lpred[i])^2\n  }\n  ssq <- sum(na.omit(epsilon))\n  return(ssq)\n}\n\nVonBertalannfyGrowth <- function(FvD){\n    Model <- list()\n    Parameters <- data.frame(SexRatio=names(FvD), Linf = NA, K = NA, t0 = NA)\n    for (i in 1:length(Fvd.list)) {\n      fert <- FvD[[i]][[2]][,2]\n      dens <- FvD[[i]][[2]][,1]\n      \n      theta <- c(1, 0.001, 0.1)\n      \n      out <- optim(theta, fn = SSQ, method = \"BFGS\", x = na.omit(dens), hessian = TRUE)\n      out$V <- solve(out$hessian)  #solve the hessian\n      out$S <- sqrt(diag(out$V))  #Standard Error\n      out$R <- out$V/(out$S %o% out$S)  #Correlation\n      Model[[i]] <- out\n      Parameters[i,2:4] <- out$par\n    }\n    return(list(Models=Model, Parameters=Parameters))\n}\n\n\nVBG.Models <- VonBertalannfyGrowth(FvD)\nVBG.Models[[2]]\n\nfert <- FvD[[5]][[2]][,2]\ndens <- FvD[[5]][[2]][,1]\n\ntheta <- c(1, 0.1, 0.1)\n\nout <- optim(theta, fn = SSQ, method = \"BFGS\", x = na.omit(dens), hessian = TRUE)\nout$par\n\n##################\n## VBGPlot\n############\n\nVBGPlot <- function(SR, FvD, Parameters) {\n  #Sex Ratio is integer from 1 to 9 relating to proportion of Males --> i.e 1 = 0.1M, 0.9F Sex Ratio\n  data <- FvD[[SR]][[2]]\n\n  fit <- Parameters[SR,2] * (1 - exp(-Parameters[SR, 3] * (data$dens - Parameters[SR,4])))\n  fit.data <- data.frame(dens=data$dens, fit=fit)\n\n  ggplot(data=data, aes(x=dens, y=fert)) +\n    geom_point() +\n    geom_smooth() +\n    geom_line(data=fit.data, aes(x=dens, y=fit), col=\"green\", size=1) +\n    labs(x=expression(CoTS~Density~(km^{-2})),\n         y=\"% of Eggs Fertilised\") +\n    ggtitle(paste(SR,\"M:\",10-SR, \"F\", sep=\"\")) +\n    theme_classic() \n  \n}\n\nParameters <- data.frame(SexRatio=names(FvD), Linf = NA, K = NA, t0 = NA)\nParameters[2,2:4] <- out$par\nVBGPlot(5, FvD, Parameters = VBG.Models[[2]])\nVBGPlot(2, FvD, Parameters)\n\n# SOmething is wrong with my optimising function\n\nEvenSexRatio <- out$par\n\n\n###################\n# CoTS_Dispersal ----\n###################\n# OBJECTIVE: Take in the amount of eggs produced as well as the fecundity by density function to determin\n#     how many larvae to disperse across our landscape via our connectivity matrix\n#    \n# PARAMS:\n#     - nLarvae: vector of number of larvae produced for each pixel\n#     - Conn: 13577x13577 Connectivity matrix containing proportion of original larvae reching every other cell\n#    \n# RETURNS:\n#     - \n#     \n###################\n\n  #############\n  # Build Dispersal Matrix (Pdist)----\n  #############\n\n  # Import coords of all of our sites ..NB for now this is the Env_Data\n  setwd(DATA_DIRECTORY)\n  PopData <- read.table(\"PopData.txt\", header = TRUE, sep = \"\\t\") \n  Coords <- PopData[,c('x','y')]\n  coordinates(Coords) <- ~x+y\n  Gdist <- gDistance(Coords, Coords, byid = T)\n  Gdist[1:10,1:10]\n  \n  # Convert to km\n  Gdist <- Gdist*100\n  \n  # Limit the distance matrix to ~500km. i.e set >500km to NA\n  Gdist[Gdist>500] <- 0\n  Gdist.Sp <- Matrix(Gdist, sparse=T)\n  \n  \n  #function to ignore NA's when summing\n  plus <- function(x) {\n    if(all(is.na(x))){\n      c(x[0],NA)} else {\n        sum(x,na.rm = TRUE)}\n  }\n  # Assume probability to be the inverse of distance --> need cumulative distrubtion function\n  Pdist <- apply(Gdist.Sp, 2, function(x) ((1/x)/plus(1/x)))\n\n#############\n#help\nCoTS_Dispersal <- \n  # Assume 30% self recruitment {REFERENCE}\n  \n  # Assume some random proportion of larvae get washed out to sea {REFERENCE}\n  \n  # Convert between distance and 0-1 proportion for remaining eggs\n\n\n\n###############################\n# CoTS_Settlement\n###############################\n# OBJECTIVE: To disperse larvae throughout the system based upon a connectivity matrix\n#    \n# PARAMS:\n#     - \n#    \n# RETURNS:\n#     - \n#     \n###################\n\n\n####################\n### COTS SANDBOX: for testing, etc.\n####################\n\n\nx = matrix(rnorm(20), ncol=4)\nrownames(x) = paste(\"X\", 1:nrow(x), sep=\".\")\ny = matrix(rnorm(12), ncol=4)\nrownames(y) = paste(\"Y\", 1:nrow(y), sep=\".\")\n\n\n#find geographic distances between all sites\n\nPop1 <- PopData\ncoordinates(Pop1) <- ~x+y\nGdist <- gDistance(Pop1, Pop1, byid = T)\n\nGdist[1:10,1:10]\n# scale geographic distances between 0-1\n\n# 1/((1-GDistNorm) - 0.5)\n\n\nm <- matrix(1, 3,3)\nv <- 1:3\nm*v\n   ## build a very rough population transition matrix... \n\n#  typical reproductive female is 300 mm in diameter\n\nMass <- COTS_MassFromDiam(300)    # 1132 grams\nFec <- COTS_FecFromMass(Mass)     # each female produces approx 14 million larvae!\n\n  # assume that maybe 0.0001 of these larvae establish on a reef\nFec <- Fec*0.0001\n\nTransMat <- matrix(c(0,0.03,0,0,0,0,0.2,0,Fec/2,0,0.3,0.1,Fec/(2*6),0,0,0.6),nrow=4)\n\n\nlambda(TransMat)         # strong positive growth rate: 3.57\nstable.stage(TransMat)   #stable age distribution\n\n#### take away: stable stage distribution is heavily biased towards juveniles \n\n",
    "created" : 1474993714025.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "2|24|18|0|\n1|35|3|0|\n28|13|49|0|\n192|0|207|58|\n211|0|223|17|\n227|0|281|31|\n284|27|284|33|\n285|0|377|17|\n381|0|432|7|\n436|0|463|23|\n",
    "hash" : "273138685",
    "id" : "B17FCA4F",
    "lastKnownWriteTime" : 1475804037,
    "path" : "~/GitHub/COTS_popmodel/COTSModel_COTSFunctions.R",
    "project_path" : "COTSModel_COTSFunctions.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}