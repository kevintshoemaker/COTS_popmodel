points(sp, xlim=c(zoomextent[1],zoomextent[2]), ylim=c(zoomextent[3],zoomextent[4]), pch=20, col="blue", cex=0.5)
points(envpoints, xlim=c(zoomextent[1],zoomextent[2]), ylim=c(zoomextent[3],zoomextent[4]), pch=17, col="red", cex=0.5)
}
plotzoom(c(145.2, 145.7, -14.9,-14.5))
plotzoom <- function (zoomextent) {
plot(reefpercent, xlim=c(zoomextent[1],zoomextent[2]), ylim=c(zoomextent[3],zoomextent[4]))
#plot(reefraster001, xlim=c(zoomextent[1],zoomextent[2]), ylim=c(zoomextent[3],zoomextent[4]), add = TRUE)
plot(reefshape, xlim=c(zoomextent[1],zoomextent[2]), ylim=c(zoomextent[3],zoomextent[4]), add = TRUE)
points(sp, xlim=c(zoomextent[1],zoomextent[2]), ylim=c(zoomextent[3],zoomextent[4]), pch=20, col="blue", cex=0.5)
points(envpoints, xlim=c(zoomextent[1],zoomextent[2]), ylim=c(zoomextent[3],zoomextent[4]), pch=17, col="red", cex=0.5)
}
plotzoom(c(145.2, 145.7, -14.9,-14.5))
windows()
plotzoom(c(145.2, 145.7, -14.9,-14.5))
EnvData <- read.table("ENV_dataGBR.txt",header=T,sep="\t")
minx <- min(EnvData$x)-0.005  # farthest west
miny <- min(EnvData$y)-0.005  # farthest south
maxx <- max(EnvData$x)+0.005  # farthest east
maxy <- max(EnvData$y)+0.005  # farthest north
studyRegion <- extent(minx,maxx,miny,maxy)
envcoords <- EnvData[,1:2]
envpoints <- SpatialPoints(coords = envcoords, proj4string = CRS(projection))
envcoords <- EnvData[,2:3]
windows()
4
plotzoom(c(145.2, 145.7, -14.9,-14.5))
data1 <- dplyr::inner_join(reefs, EnvData, by = c("x", "y"))
min.d <- apply(Gdist, 2, which.min) #creates vector of the minimum distances which we use to index the cords
min.gd <- apply(Gdist, 2, min) #creates a vecor of the min dist so we can see how far they have been displaced
head(Gdist)
reef.NA$min.gd <- min.gd
max(min.gd)
summary(min.gd)
head(reef.NA)
coord.matches <- cbind(reef.NA[1:3],reef.YES[min.d,1:2], min.gd)
reef.NAdf <- as.data.frame(reef.NA)
reef.YESdf <- as.data.frame(reef.YES)
coord.matches <- cbind(reef.NAdf[1:2],reef.YES[min.d,1:2], min.gd)
coord.matches <- cbind(reef.NAdf[,1:2],reef.YES[min.d,1:2], min.gd)
coord.matches <- cbind(reef.NAdf[,1:2],reef.YESdf[min.d,1:2], min.gd)
View(coord.matches)
plotzoom(c(151.4, 151.8, -23.03,-22.55))
reefshape <- readShapefile("MarineBioregions_WGS84", projection = projection, plot=T)
loadPackages()   # load all packages into the global environment
reefshape <- readShapefile("MarineBioregions_WGS84", projection = projection, plot=T)
crs(reefshape)
projection
plotzoom(c(151.4, 151.8, -23.03,-22.55))
plotzoom(c(151.4, 151.8, -23.03,-22.55))
CRS(projection)
projection <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"   #"+proj=lcc +lat_1=33 +lat_2=45 +lat_0=39 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs"
CRS(projection)
minx <- min(EnvData$x)-0.005  # farthest west
miny <- min(EnvData$y)-0.005  # farthest south
maxx <- max(EnvData$x)+0.005  # farthest east
maxy <- max(EnvData$y)+0.005  # farthest north
studyRegion <- extent(minx,maxx,miny,maxy)
cat(sprintf("Western margin is %s degrees, southern margin is %s degrees, eastern margin is %s degrees, and northern margin is %s degrees",minx,miny,maxx,maxy))
plot(studyRegion, main="Study Region (blank)")
template <- raster(ext=studyRegion,resolution=0.01,vals=0)   # create empty raster
template <- raster(ext=studyRegion,resolution=0.01,vals=0, crs = projection)   # create empty raster
template001 <- raster(ext=studyRegion,resolution=0.001,vals=0, crs = projection)   # create empty raster at 0.001 res
writeRaster(template,filename="templateRaster.asc",format="ascii",overwrite=T)   # write to file
setwd(SPATIALDATA_DIRECTORY)
writeRaster(template,filename="templateRaster.asc",format="ascii",overwrite=T)   # write to file
reefraster001@crs
reefraster001 <- rasterize(reefshape, template001, field = NA, crs = projection)
sp <- SpatialPoints(coords = coords, proj4string = projection)
sp <- SpatialPoints(coords = coords, proj4string = CRS(projection))
setwd(SPATIALDATA_DIRECTORY)
writeGDAL(reefpercent, fnam="reefpercent.tif", drivername = "GTiff")
writeRaster(reefpercent,filename="reefPercentRaster.grd",format="raster",overwrite=T)   # write to file
writeGDAL(reefpercent, fnam="reefpercent.tif", drivername = "GTiff", type = "Float32")
writeRaster(reefpercent,filename="reefPercentRaster.tif",format="GTiff",overwrite=T)   # write to file
rp1 <- ReadRaster("reefPercentRaster.tif")
rp1 <- ReadRaster("reefPercentRaster.tif", projection=projection, plot=T)
rm(rp1)
reefraster001 <- rasterize(reefshape, template001, field = NA, crs = projection)
extent(reefshape)
extent(reefshape) <- extent
extent(reefshape) <- studyRegion
plot(reefshape)
plot(reefpercent, add=TRUE)
plot(reefpercent)
plot(reefshape, add=T)
reefraster001 <- rasterize(reefshape, template001, field = NA, crs = projection)
reefraster001 <- rasterize(reefshape, template001, field = "BIOREGION", crs = projection)
reefraster001 <- rasterize(reefshape, template001, field = "REEF_ID", crs = projection)
plot(reefpercent)
plot(reefshape, add=T)
plot(envpoints, pch=17, col="blue", cex=0.4)
plot(reefpercent)
plot(reefshape, add=T)
points(envpoints, pch=17, col="blue", cex=0.4)
template <- raster(ext=studyRegion,resolution=0.01,vals=0, crs = projection)   # create empty raster
template001 <- raster(ext=studyRegion,resolution=0.001,vals=0, crs = projection)   # create empty raster at 0.001 res
setwd(SPATIALDATA_DIRECTORY)
writeRaster(template,filename="templateRaster.asc",format="ascii",overwrite=T)   # write to file
reefraster001 <- rasterize(reefshape, template001, field = "REEF_ID", crs = projection)
sum(reefpercent@data>50)
sum(reefpercent@data@values>50)
summary(reef.NAdf$reefpercent)
reefs <- na.omit(cbind(coordinates(sp), vals, reefpercent = reefpercent.df[,3]))
reefs <- (cbind(coordinates(sp), vals, reefpercent = reefpercent.df[,3])
reefs <- cbind(coordinates(sp), vals, reefpercent = reefpercent.df[,3])
reefs <- cbind(coordinates(sp), vals, reefpercent = reefpercent.df[,3])
data1 <- dplyr::inner_join(reef.YESdf, EnvData, by = c("x", "y"))
View(EnvData)
data1 <- merge(reef.YESdf, EnvData, by = c("x", "y"))
View(data1)
data <- merge(reef.YESdf, EnvData, by = c("x", "y"))
rm(data1)
write.table(data, "ENVData_all.txt")
setwd(DATA_DIRECTORY)
write.table(data, "ENVData_all.txt")
write.table(data, "ENVData_all.txt", row.names = F, overwrite=T)
write.table(data, "ENVData_all.txt", row.names = F)
write.table(data, "ENVData_all.txt", row.names = F, sep = "\t")
ReadRaster("reefraster2.asc", projection = projection, plot=t)
setwd(DATA_DIRECTORY)
reefraster <- ReadRaster("reefraster2.asc",projection=projection,plot=F)   # uses "ReadRaster" utility function
reefraster <- reclassify(reefraster,rcl=c(NA,NA,0, -Inf,0.5,0, 0.6,Inf,1))  # temporary layer: reclassify to binary
compute_percentReef <- function(t,na.rm=TRUE) sum(t,na.rm)  ## aggregation function
reefpercent <- aggregate(reefraster, fact=10, fun=compute_percentReef, expand=TRUE, na.rm=TRUE)
reefpercent <- reefpercent-1    # for some reason, the result ends up between 1 and 101- reformulate for proper percent
plot(reefpercent)
setwd(SPATIALDATA_DIRECTORY)
writeRaster(reefpercent,filename="reefPercentRaster.asc",format="ascii",overwrite=T)   # write to file
setwd(ENVDATA_DIRECTORY)    # first load the xyz data for each population of interest
PopData <- read.table("ENV_dataGBR.txt",header=T,sep="\t")
reefpercent.df <- data.frame(data.frame(x = coordinates(reefpercent)[,1], y = coordinates(reefpercent)[,2], reefpercent = reefpercent@data@values))
reefpercent.df <- subset(reefpercent.df, reefpercent>0)
coords <- reefpercent.df[,1:2]
sp <- SpatialPoints(coords = coords, proj4string = CRS(projection))
PopData1 <- merge(Coords, PopData, by=c('x', 'y')
PopData1 <- merge(Coords, PopData, by=c('x', 'y'))
PopData1 <- merge(Coords, PopData, by=c('x', 'y'))
PopData1 <- merge(coords, PopData, by=c('x', 'y'))
PopData <- merge(coords, PopData, by=c('x', 'y'))
rm(PopData1)
NPOPS <- nrow(PopData)
minx <- min(PopData$x)-0.005  # farthest west
miny <- min(PopData$y)-0.005  # farthest south
maxx <- max(PopData$x)+0.005  # farthest east
maxy <- max(PopData$y)+0.005  # farthest north
studyRegion <- extent(minx,maxx,miny,maxy)
cat(sprintf("Western margin is %s degrees, southern margin is %s degrees, eastern margin is %s degrees, and northern margin is %s degrees",minx,miny,maxx,maxy))
EnvData <- read.table("ENV_dataGBR.txt",header=T,sep="\t")
PopData <- read.table("ENV_dataGBR.txt",header=T,sep="\t")
PopData <- merge(coords, PopData, by=c('x', 'y'))
minx <- min(PopData$x)-0.005  # farthest west
miny <- min(PopData$y)-0.005  # farthest south
maxx <- max(PopData$x)+0.005  # farthest east
maxy <- max(PopData$y)+0.005  # farthest north
studyRegion <- extent(minx,maxx,miny,maxy)
cat(sprintf("Western margin is %s degrees, southern margin is %s degrees, eastern margin is %s degrees, and northern margin is %s degrees",minx,miny,maxx,maxy))
plot(studyRegion, main="Study Region (blank)")
setwd(SPATIALDATA_DIRECTORY)
save(studyRegion,file="studyRegion.RData")
template <- raster(ext=studyRegion,resolution=0.01,vals=0, crs=projection)   # create empty raster
reefID <- as.numeric(PopData$REEF_ID)
ndx <- !is.na(reefID)
reefIDraster <- rasterize(PopData[,c('x','y')][ndx,], template, field=reefID[ndx])   # memory limitations
setwd(SPATIALDATA_DIRECTORY)
writeRaster(reefIDraster,filename="reefIDRaster.asc",format="ascii",overwrite=T)   # write to file
plot(reefIDraster)
rm(reefpercent) # remove from memory (save space!)
rm(reefraster)
setwd(DATA_DIRECTORY)
write.table(PopData, "PopData.txt", sep="\t")
View(PopData)
PopData$PIXELID <- 1:nrows(PopData)
PopData$PIXELID <- 1:n.rows(PopData)
PopData$PIXELID <- 1:nrow(PopData)
write.table(PopData, "PopData.txt", sep="\t")
View(PopData)
setwd(ENVDATA_DIRECTORY)    # first load the xyz data for each population of interest
PopData <- read.table("ENV_dataGBR.txt",header=T,sep="\t")
PopData <- merge(coords, PopData, by=c('x', 'y'))
PopData <- read.table("ENV_dataGBR.txt",header=T,sep="\t", row.names = T)
PopData$PIXELID <- 1:nrow(PopData)
PopData <- PopData[,c(38,1:37)]
View(PopData)
setwd(DATA_DIRECTORY)
write.table(PopData, "PopData.txt", sep="\t")
NPOPS <- nrow(PopData)
reefIDraster <- rasterize(PopData[,c('x','y')][ndx,], template, field=reefID[ndx])   # memory limitations
setwd(SPATIALDATA_DIRECTORY)
writeRaster(reefIDraster,filename="reefIDRaster.asc",format="ascii",overwrite=T)   # write to file
plot(reefIDraster)
0.22*(100/22)
1500*(100/22)
PopData <- merge(coords, PopData, by=c('x', 'y'))
PopData <- merge(reefpercent.df, PopData, by=c('x', 'y'))
PopData <- read.table("ENV_dataGBR.txt",header=T,sep="\t")
setwd(ENVDATA_DIRECTORY)    # first load the xyz data for each population of interest
PopData <- read.table("ENV_dataGBR.txt",header=T,sep="\t")
PopData <- merge(reefpercent.df, PopData, by=c('x', 'y'))
PopData <- read.table("ENV_dataGBR.txt",header=T,sep="\t")
PopData <- merge(reefpercent.df, PopData, by=c('x', 'y'))
PopData$PIXELID <- 1:nrow(PopData)
PopData <- PopData[,c(39,1:38)]
sum(unique(PopData$REEF_ID)
)
count(unique(PopData$REEF_ID))
sum(is.unique(PopData$REEF_ID))
length(unique(PopData$REEF_ID))
PopData <- read.table("ENV_dataGBR.txt",header=T,sep="\t")
PopData <- merge(reefpercent.df, PopData, by=c('x', 'y'))
PopData$PIXEL_ID <- 1:nrow(PopData)
PopData <- PopData[,-4]
PopData <- PopData[,c(38,1:37)]
setwd(DATA_DIRECTORY)
write.table(PopData, "PopData.txt", sep="\t")
setwd(DATA_DIRECTORY)
manta <- read.csv("ltmp/manta.csv") #LTMP Manta Tow Data
PopData <- read.table("PopData.txt", sep = "\t") #GBRMPA 0.01 degree grid
colnames(manta)[6] <- "LONG"
manta_year <- ddply(manta, c("REEF_NAME", "LONG", "LAT", "REPORT_YEAR"),
summarise, mean_COTS = mean(COT_COUNT)) %>%
dcast(REEF_NAME + LAT + LONG ~ REPORT_YEAR, value.var="mean_COTS")
loadPackages <- function(){
loadPackage("lhs")            # for latin hypercube sampling
loadPackage("RCurl")          # for loading source code from github
loadPackage("raster")         # for managing raster data
loadPackage("rgdal")          # for reading and writing all sorts of spatial data
loadPackage("popbio")         # for doing basic matrix population modeling
loadPackage("tidyverse")      # data manipulation
loadPackage("rgeos")          # geometry applications
loadPackage("ddply")          # data wrangling
}
loadPackages()   # load all packages into the global environment
manta_year <- ddply(manta, c("REEF_NAME", "LONG", "LAT", "REPORT_YEAR"),
summarise, mean_COTS = mean(COT_COUNT)) %>%
dcast(REEF_NAME + LAT + LONG ~ REPORT_YEAR, value.var="mean_COTS")
source('~/GitHub/COTS_popmodel/COTSModel_PrepareWorkspace.R', echo=TRUE)
loadPackages <- function(){
loadPackage("lhs")            # for latin hypercube sampling
loadPackage("RCurl")          # for loading source code from github
loadPackage("raster")         # for managing raster data
loadPackage("rgdal")          # for reading and writing all sorts of spatial data
loadPackage("popbio")         # for doing basic matrix population modeling
loadPackage("tidyverse")      # data manipulation
loadPackage("rgeos")          # geometry applications
loadPackage("dplyr")          # data wrangling
}
loadPackages()   # load all packages into the global environment
loadPackages <- function(){
loadPackage("lhs")            # for latin hypercube sampling
loadPackage("RCurl")          # for loading source code from github
loadPackage("raster")         # for managing raster data
loadPackage("rgdal")          # for reading and writing all sorts of spatial data
loadPackage("popbio")         # for doing basic matrix population modeling
loadPackage("tidyverse")      # data manipulation
loadPackage("rgeos")          # geometry applications
loadPackage("plyr")           # data wrangling
loadPackage("dplyr")          # data wrangling
}
loadPackages()
setwd(DATA_DIRECTORY)
manta <- read.csv("ltmp/manta.csv") #LTMP Manta Tow Data
PopData <- read.table("PopData.txt", sep = "\t") #our environmental data grid
colnames(manta)[6] <- "LONG"
manta_year <- ddply(manta, c("REEF_NAME", "LONG", "LAT", "REPORT_YEAR"),
summarise, mean_COTS = mean(COT_COUNT)) %>%
dcast(REEF_NAME + LAT + LONG ~ REPORT_YEAR, value.var="mean_COTS")
loadPackages <- function(){
loadPackage("lhs")            # for latin hypercube sampling
loadPackage("RCurl")          # for loading source code from github
loadPackage("raster")         # for managing raster data
loadPackage("rgdal")          # for reading and writing all sorts of spatial data
loadPackage("popbio")         # for doing basic matrix population modeling
loadPackage("tidyverse")      # data manipulation
loadPackage("rgeos")          # geometry applications
loadPackage("plyr")           # data wrangling
loadPackage("dplyr")          # data wrangling
loadPackage("reshape2")       # data wrangling
}
loadPackages()
manta_year <- ddply(manta, c("REEF_NAME", "LONG", "LAT", "REPORT_YEAR"),
summarise, mean_COTS = mean(COT_COUNT)) %>%
dcast(REEF_NAME + LAT + LONG ~ REPORT_YEAR, value.var="mean_COTS")
coordinates(manta_year) = ~LONG+LAT
coordinates(PopData) = ~x+y
gridded(PopData) = TRUE
XYZ <- read.csv("XYZGrid.csv") #GBRMPA 0.01 degree grid
PopData <- read.table("PopData.txt", sep = "\t") #our environmental data grid
PopData <- PopData[,-c(6:38)]
coordinates(PopData) = ~ x + y
gridded(PopData) = TRUE
idw.interpolation.df <- function(Year, maxdist, nmin) { ## returns the object as a list of dataframes
#first we need to subset the manta_year data set
Obs = na.omit(data.frame(manta_year[,2:3],manta_year[,Year-1983 +4])) #create observations of CoTS for year i
colnames(Obs)[3] = "mean.COTS"
coordinates(Obs) = ~LONG+LAT
COTS.idw = as.data.frame(idw(mean.COTS~1, Obs, XYZ, maxdist = maxdist, nmin= nmin))
#results = spplot(COTS.idw["var1.pred"], main = "CoTS interpolation")
return(COTS.idw)
}
COTS.interpolation.df <- lapply(Years, FUN = idw.interpolation.df, maxdist=1, nmin=3)
Years <- 1996
COTS.interpolation.df <- lapply(Years, FUN = idw.interpolation.df, maxdist=1, nmin=3)
manta_year <- ddply(manta, c("REEF_NAME", "LONG", "LAT", "REPORT_YEAR"),
summarise, mean_COTS = mean(COT_COUNT)) %>%
dcast(REEF_NAME + LAT + LONG ~ REPORT_YEAR, value.var="mean_COTS")
COTS.interpolation.df <- lapply(Years, FUN = idw.interpolation.df, maxdist=1, nmin=3)
loadPackages <- function(){
loadPackage("lhs")            # for latin hypercube sampling
loadPackage("RCurl")          # for loading source code from github
loadPackage("raster")         # for managing raster data
loadPackage("rgdal")          # for reading and writing all sorts of spatial data
loadPackage("popbio")         # for doing basic matrix population modeling
loadPackage("tidyverse")      # data manipulation
loadPackage("rgeos")          # geometry applications
loadPackage("plyr")           # data wrangling
loadPackage("dplyr")          # data wrangling
loadPackage("reshape2")       # data wrangling
loadPackage("gstat")          # performing interpolation
}
loadPackages()
COTS.interpolation.df <- lapply(Years, FUN = idw.interpolation.df, maxdist=1, nmin=3)
Obs = na.omit(data.frame(manta_year[,2:3],manta_year[,1996-1983 +4]))
colnames(Obs)[3] = "mean.COTS"
coordinates(Obs) = ~LONG+LAT
COTS.idw = idw(mean.COTS~1, Obs, PopData)
class(COTS.idw)
plot(COTS.idw)
idw.interpolation <- function(Year, maxdist, nmin) { ## returns an interpolated Spatial Pixels Data Frame
#first we need to subset the manta_year data set
Obs = na.omit(data.frame(manta_year[,2:3],manta_year[,Year-1983 +4])) #create observations of CoTS for year i
colnames(Obs)[3] = "mean.COTS"
coordinates(Obs) = ~LONG+LAT
COTS.idw = as.data.frame(idw(mean.COTS~1, Obs, XYZ, maxdist = maxdist, nmin= nmin))
#results = spplot(COTS.idw["var1.pred"], main = "CoTS interpolation")
return(COTS.idw)
}
idw.interpolation(1996, PopData, 1,3)
idw.interpolation <- function(Year, XYZ, maxdist, nmin) { ## returns an interpolated Spatial Pixels Data Frame
#first we need to subset the manta_year data set
Obs = na.omit(data.frame(manta_year[,2:3],manta_year[,Year-1983 +4])) #create observations of CoTS for year i
colnames(Obs)[3] = "mean.COTS"
coordinates(Obs) = ~LONG+LAT
COTS.idw = as.data.frame(idw(mean.COTS~1, Obs, XYZ, maxdist = maxdist, nmin= nmin))
#results = spplot(COTS.idw["var1.pred"], main = "CoTS interpolation")
return(COTS.idw)
}
idw.interpolation(1996, PopData, 1,3)
COTS.idw.1996 <- idw.interpolation(1996, PopData, 1,3)
idw.interpolation.df <- function(Year, XYZ, maxdist, nmin) { ## returns an interpolated Data Frame
#first we need to subset the manta_year data set
Obs = na.omit(data.frame(manta_year[,2:3],manta_year[,Year-1983 +4])) #create observations of CoTS for year i
colnames(Obs)[3] = "mean.COTS"
coordinates(Obs) = ~LONG+LAT
COTS.idw = as.data.frame(idw(mean.COTS~1, Obs, XYZ, maxdist = maxdist, nmin= nmin))
#results = spplot(COTS.idw["var1.pred"], main = "CoTS interpolation")
return(COTS.idw)
}
Years <- 1996:1997
COTS.interpolation.df <- lapply(Years, FUN = idw.interpolation.df, maxdist=1, nmin=3)
COTS.interpolation.df <- lapply(Years, FUN = idw.interpolation.df, XYZ=PopData, maxdist=1, nmin=3)
names(COTS.interpolation.df) <- Years #name the list so they can be retrieved by year
Years <- 1985:2015
COTS.interpolation.df <- lapply(Years, FUN = idw.interpolation.df, XYZ=PopData, maxdist=1, nmin=3)
names(COTS.interpolation.df) <- Years #name the list so they can be retrieved by year
idw.interpolation <- function(Year, XYZ, maxdist, nmin) {
#first we need to subset the manta_year data set
Obs = na.omit(data.frame(manta_year[,2:3],manta_year[,Year-1983 +4])) #create observations of CoTS for year i
colnames(Obs)[3] = "mean.COTS"
coordinates(Obs) = ~LONG+LAT
COTS.idw = idw(mean.COTS~1, Obs, XYZ, maxdist = maxdist, nmin= nmin)
#results = spplot(COTS.idw["var1.pred"], main = "CoTS interpolation")
return(COTS.idw)
}
for(i in 1:length(COTS.interpolation.df)) names(COTS.interpolation.df[[i]])[3] <- paste0("X",1982+i)
Years <- 1983:2015
COTS.interpolation.df <- lapply(Years, FUN = idw.interpolation.df, XYZ=PopData, maxdist=1, nmin=3)
names(COTS.interpolation.df) <- Years #name the list so they can be retrieved by year
for(i in 1:length(COTS.interpolation.df)) names(COTS.interpolation.df[[i]])[3] <- paste0("X",1982+i)
for(i in 1:length(COTS.interpolation.df)) COTS.interpolation.df[[i]][4] <- NULL
XYZ_COTS.int <- Reduce(function(x,y)merge(x,y, by=c("LAT", "LONG")), COTS.interpolation.df)
XYZ_COTS.int <- Reduce(function(x,y)merge(x,y, by=c("x", "y")), COTS.interpolation.df)
COTSInterp <- Reduce(function(x,y)merge(x,y, by=c("x", "y")), COTS.interpolation.df)
COTSInterp <- left_join(PopData, COTSInterp, by=c("x", "y"))
COTSInterp1 <- left_join(as.data.frame(PopData), COTSInterp, by=c("x", "y"))
COTSInterp <- left_join(as.data.frame(PopData), COTSInterp, by=c("x", "y"))
write.table(COTSInterp, file = "COTS_Intepolated.txt", row.names = F, sep="\t")
COTSInterp1 <- read.table("COTS_Interpolated.txt", sep = "\t")
COTSInterp1 <- read.table("COTS_Intepolated.txt", sep = "\t")
COTSInterp1 <- read.table("COTS_Interpolated.txt", sep = "\t", header = TRUE)
COTSInterp1 <- read.table("COTS_Intepolated.txt", sep = "\t", header = TRUE)
write.table(COTSInterp, file = "COTS_Interpolated.txt", row.names = F, sep="\t")
COTSInterp1 <- read.table("COTS_Interpolated.txt", sep = "\t", header = TRUE)
COTSInterp <- COTSInterp[,c(4:5,1:3,6:38)]
COTSInterp <- Reduce(function(x,y)merge(x,y, by=c("x", "y")), COTS.interpolation.df)
COTSInterp <- left_join(as.data.frame(PopData), COTSInterp, by=c("x", "y"))
COTSInterp <- COTSInterp[,c(1,4:5,2:3,6:38)]
setwd(DATA_DIRECTORY)
write.table(COTSInterp, file = "COTS_Interpolated.txt", row.names = F, sep="\t")
COTSInterp1 <- read.table("COTS_Interpolated.txt", sep = "\t", header = TRUE)
save.image("C:/Users/jc312264/Dropbox/CoTS_Model/R_Workspaces/COTS_Interpolation_2016_09_28.RData")
source('~/GitHub/COTS_popmodel/COTSModel_PrepareWorkspace.R', echo=TRUE)
setwd(DATA_DIRECTORY)
PopData <- read.table("PopData.txt", header = TRUE, sep = "\t")
stagenames <- c('J_1', 'J_2', 'A')
initializeCOTSabund <- function(PopData, COTSInterp, Year, stagenames, COTS_StableStage){
### set NA Values in interpolation to 0
COTSInterp[is.na(COTSInterp)] <- 0
### Set up the COTS abundance object
COTSabund <- matrix(0,nrow=npops, ncol=nstages)
colnames(COTSabund) <- stagenames
### Set up reference for year
colname <- paste('X', Year, sep="")
### Update abundances based from interpolated manta tow data
COTSabund[,'A'] <- COTSInterp[,colname] * 1500 * (PopData$reefpercent/100)   #need to multiply by function from observations to density
COTSabund[,'J_2'] <- COTSabund[,'A'] * (COTS_StableStage[2]/COTS_StableStage[3])
COTSabund[,'J_1'] <- COTSabund[,'A'] * (COTS_StableStage[1]/COTS_StableStage[3])
return(COTSabund)
}
initCOTS <- initializeCOTSabund(PopData = PopData, COTSInterp = COTSInterp, Year=1996, stagenames, COTS_StableStage = COTS_StableStage)
COTSInterp <- read.table("COTS_Interpolated.txt", header = TRUE, sep = "\t")
initCOTS <- initializeCOTSabund(PopData = PopData, COTSInterp = COTSInterp, Year=1996, stagenames, COTS_StableStage = COTS_StableStage)
npops <- length(PopData[,1])
COTSabund <- matrix(0,nrow=npops, ncol=nstages)
initializeCOTSabund <- function(PopData, COTSInterp, Year, stagenames, COTS_StableStage){
### set NA Values in interpolation to 0
COTSInterp[is.na(COTSInterp)] <- 0
npops <- length(PopData[,1])
### Set up the COTS abundance object
COTSabund <- matrix(0,nrow=npops, ncol=nstages)
colnames(COTSabund) <- stagenames
### Set up reference for year
colname <- paste('X', Year, sep="")
### Update abundances based from interpolated manta tow data
COTSabund[,'A'] <- COTSInterp[,colname] * 1500 * (PopData$reefpercent/100)   #need to multiply by function from observations to density
COTSabund[,'J_2'] <- COTSabund[,'A'] * (COTS_StableStage[2]/COTS_StableStage[3])
COTSabund[,'J_1'] <- COTSabund[,'A'] * (COTS_StableStage[1]/COTS_StableStage[3])
return(COTSabund)
}
initCOTS <- initializeCOTSabund(PopData = PopData, COTSInterp = COTSInterp, Year=1996, stagenames, COTS_StableStage = COTS_StableStage)
initializeCOTSabund <- function(PopData, COTSInterp, Year, stagenames, COTS_StableStage){
### set NA Values in interpolation to 0
COTSInterp[is.na(COTSInterp)] <- 0
npops <- length(PopData[,1])
nstages <- length(stagenames)
### Set up the COTS abundance object
COTSabund <- matrix(0,nrow=npops, ncol=nstages)
colnames(COTSabund) <- stagenames
### Set up reference for year
colname <- paste('X', Year, sep="")
### Update abundances based from interpolated manta tow data
COTSabund[,'A'] <- COTSInterp[,colname] * 1500 * (PopData$reefpercent/100)   #need to multiply by function from observations to density
COTSabund[,'J_2'] <- COTSabund[,'A'] * (COTS_StableStage[2]/COTS_StableStage[3])
COTSabund[,'J_1'] <- COTSabund[,'A'] * (COTS_StableStage[1]/COTS_StableStage[3])
return(COTSabund)
}
initCOTS <- initializeCOTSabund(PopData = PopData, COTSInterp = COTSInterp, Year=1996, stagenames, COTS_StableStage = COTS_StableStage)
COTS_StableStage <- c(0.9803, 0.0171, 0.0026)   # very approximate stable stage distribution (J1, J2, Adult: see below for back-of-the-envelope calculation)
COTS_MassFromDiam <- function(Diam){
Mass <- 6.29*10^-5*Diam^2.929
return(Mass)
}
# converts female mass to total larval fecundity
COTS_FecFromMass <- function(Mass){
Fec <- 558*Mass^1.439
return(Fec)
}
initCOTS <- initializeCOTSabund(PopData = PopData, COTSInterp = COTSInterp, Year=1996, stagenames, COTS_StableStage = COTS_StableStage)
COTSmort <- c(0.7,0.4,0.1)
names(COTSmort) <- stagenames
COTSremain <- c(0.02,0.2,1) # proportion remianing in each life stage --> we can make this a function of resource
names(COTSremain) <- stagenames
COTS_StageTransition <- function(COTSabund, COTSmort, COTSremain) {
#Set up matrices
newCOTSabund <- matrix(0,nrow=nrow(COTSabund), ncol=ncol(COTSabund))
colnames(newCOTSabund) <- colnames(COTSabund)
COTS_Mort <- matrix(0,nrow=nrow(COTSabund), ncol=ncol(COTSabund))
colnames(COTS_Mort) <- colnames(COTSabund)
COTS_Remain <- matrix(0,nrow=nrow(COTSabund), ncol=ncol(COTSabund))
colnames(COTS_Remain) <- colnames(COTSabund)
COTS_Trans <- matrix(0,nrow=nrow(COTSabund), ncol=ncol(COTSabund))
colnames(COTS_Trans) <- colnames(COTSabund)
# apply mortality
COTS_Mort <- sweep(COTSabund,MARGIN=2,COTSmort,`*`)
# update abundance
newCOTSabund <- COTSabund - COTS_Mort
# number of COTS remaining and transitioning for each stage based on post-mortality abundaces
COTS_Remain <- sweep(newCOTSabund,MARGIN=2,COTSremain,`*`)
COTS_Trans <- sweep(newCOTSabund,MARGIN=2,1-COTSremain,`*`)
# update newCOTSabund
newCOTSabund[, 'J_1'] <- COTS_Remain[,'J_1']
newCOTSabund[, 'J_2'] <- COTS_Remain[,'J_2'] + COTS_Trans[,'J_1']
newCOTSabund[, 'A'] <- COTS_Remain[,'A'] + COTS_Trans[,'J_2']
return(newCOTSabund)
}
t1 <- COTS_StageTransition(COTSabund = initCOTS, COTSmort = COTSmort, COTSremain = COTSremain)
head(t1)
head(initCOTS)
COTS_Fecundity <- function(COTSabund, mean, sd, npops) {
### Intitialize matrix to store total eggs
COTS_Eggs <- vector(mode = "numeric", length = npops)
for (r in 1:npops) {
Sizes <- rnorm(COTSabund[r,'A'], mean, sd)
COTS_Eggs[r] <- sum(COTS_FecFromMass(COTS_MassFromDiam(Sizes)))
}
return(COTS_Eggs)
}
EGGS <- COTS_Fecundity(t1, 35, 10, npops)
Pop1 <- PopData
coordinates(Pop1) <- ~x+y
Gdist <- gDistance(Pop1, Pop1, byid = T)
save.image("C:/Users/jc312264/Dropbox/CoTS_Model/R_Workspaces/COTS_Model_2016-09-06.RData")
Gdist[1:10,1:10]
